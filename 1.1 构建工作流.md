cmake -S. -Bbuild

cmake --build build

你给出的这两行命令是 **Modern CMake (3.13+)** 中最标准、最推荐的构建工作流。这种方式被称为 **“非源码构建” (Out-of-source Build)**。

下面我为你详细解析这两行命令背后的含义，以及它们解决了什么问题。

---

### 1. 第一阶段：配置 (Configuration)

Bash

```
cmake -S . -B build
```

- **`-S .` (Source)**: 指定源文件所在的目录。`.` 代表当前目录（即包含 `CMakeLists.txt` 的地方）。
    
- **`-B build` (Build)**: 指定生成中间文件、构建工件（如 Makefile 或工程文件）的目录。如果 `build` 文件夹不存在，CMake 会自动为你创建。
    
- **执行了什么？**
    
    - 检测编译器（gcc, clang, msvc 等）。
        
    - 检查依赖项（find_package）。
        
    - 解析 `CMakeLists.txt`。
        
    - 在 `build` 目录下生成构建系统（例如在 Linux 上生成 `Makefile`，在 Windows 上生成 `.sln`）。
        

---

### 2. 第二阶段：构建 (Build)

Bash

```
cmake --build build
```

- **`--build build`**: 告诉 CMake 去 `build` 目录执行实际的编译操作。
    
- **为什么不直接用 `make`？**
    
    - **跨平台通用性**：这是最重要的原因。如果你在 Linux 上，这行命令会自动调用 `make`；如果你在 Windows 上，它会调用 `msbuild`；如果你用了 Ninja，它会调用 `ninja`。
        
    - **抽象化**：你不需要关心底层的构建工具是什么，只需要跟 CMake 交互。
        

---

### 3. 这种写法的好处

相比于老旧的 `mkdir build && cd build && cmake ..` 写法，这种现代写法有以下优势：

1. **无需切换目录**：你始终停留在项目的根目录下，不会因为 `cd` 来 `cd` 去而搞混路径。
    
2. **保持源码整洁**：所有的中间文件（`.o`, `.obj`）和生成的工程文件都在 `build` 目录中。如果你想彻底清理项目，直接 `rm -rf build` 即可，不会污染你的源代码。
    
3. **脚本友好**：在 CI/CD（如 GitHub Actions）中，这种单行命令非常容易自动化。
    

---

### 4. 常用进阶参数

在实际开发中，你可能还会用到这些变体：

- **指定构建类型 (Debug/Release)**:
    
    Bash
    
    ```
    cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
    ```
    
- **并行编译 (加速)**:
    
    Bash
    
    ```
    # 使用所有 CPU 核心进行编译
    cmake --build build -j $(nproc) 
    ```
    
- **安装 (Install)**:
    
    Bash
    
    ```
    # 将编译好的二进制文件安装到系统或指定目录
    cmake --install build --prefix ./dist
    ```

