在进入“编程”逻辑（第二阶段）之前，彻底搞懂 **1.5阶段** 的目标属性与库类型，能让你避免 90% 的链接错误。

---

### 1. 库的两种形态：静态库 vs. 动态库

在执行 `add_library(MyLib src/math.cpp)` 时，CMake 默认通常生成的是**静态库**。

#### **静态库 (Static Library)**

- **后缀**：Linux 为 `.a`，Windows 为 `.lib`。
    
- **特点**：编译时会被完整“复制”到最终的可执行文件中。
    
- **优点**：分发方便，运行程序时不需要带一堆库文件。
    
- **写法**：`add_library(MyLib STATIC src/math.cpp)`
    

#### **动态库 (Shared Library)**

- **后缀**：Linux 为 `.so`，Windows 为 `.dll`，macOS 为 `.dylib`。
    
- **特点**：编译时不拷贝，只记录一个“引用”。程序运行时去系统路径或指定目录加载。
    
- **优点**：节省空间（多个程序共用一个 `.so`），方便插件化更新。
    
- **写法**：`add_library(MyLib SHARED src/math.cpp)`
    

> 进阶技巧： > 实际开发中，建议不写死类型。通过设置 add_library(MyLib src/math.cpp)，然后在命令行传参：
> 
> cmake -S . -B build -DBUILD_SHARED_LIBS=ON
> 
> 这样可以一键把整个项目的所有库都在“全静态”和“全动态”之间切换。

---

### 2. 深度剖析：可见性（Visibility）的实战意义

这是 Modern CMake 的“核心价值观”。当你调用 `target_include_directories` 或 `target_link_libraries` 时，必须选择一个关键字：

#### **A. PRIVATE（私有）**

- **含义**：这个东西只有我自己用，链接我的人不需要知道。
    
- **例子**：你的库里用到了一些复杂的数学逻辑，引用了一个第三方的 `internal_math.h`。但用户调用你的库只需要看到 `api.h`。
    
- **效果**：`internal_math.h` 的路径不会传递给可执行文件。
    

#### **B. INTERFACE（接口）**

- **含义**：我自己编译时不需要，但谁链接我，谁就得用它。
    
- **例子**：**纯头文件库（Header-only Library）**。这类库不需要编译（没有 `.cpp`），只要把路径告诉别人就行。
    
- **写法**：`add_library(MyHeaderLib INTERFACE)`
    

#### **C. PUBLIC（公共）**

- **含义**：我自己要用，链接我的人也得跟着用。
    
- **例子**：你的 `my_math.h` 放在 `include/` 下。你编译库的时候需要它，别人调用你的函数也必须 `#include` 它。
    

---

### 3. 一个极具代表性的例子

假设我们要构建这样一个项目：

1. **EngineLib** (库)：它的头文件里用到了 **OpenGL** 的定义。
    
2. **App** (程序)：链接 **EngineLib**。
    

CMake

```
# EngineLib 需要 OpenGL 的头文件
# 因为 EngineLib 的公开头文件里包含了 <GL/gl.h>
# 所以必须用 PUBLIC，否则 App 编译时会找不到 GL/gl.h
target_include_directories(EngineLib PUBLIC ${OPENGL_INCLUDE_DIRS})

# EngineLib 内部实现用了 zlib 来压缩数据
# 但 App 根本不知道 zlib 的存在，App 只负责调用 EngineLib 的接口
# 所以用 PRIVATE
target_link_libraries(EngineLib PRIVATE ZLIB::ZLIB)
```

---

### 4. 1.5阶段的自测清单

如果你能回答出以下问题，说明你可以直接跳入第二阶段：

1. **为什么我的 `main.cpp` 编译报错说找不到头文件，明明我在库的 `CMakeLists.txt` 里已经包含了？**
    
    - _答案思路：检查是否用了 `PRIVATE` 而不是 `PUBLIC`。_
        
2. **如果我有一个库只有 `.h` 文件，我该用 `add_library` 的哪个参数？**
    
    - _答案思路：`INTERFACE`。_
        
3. **在 Windows 上生成动态库（DLL）是不是只要写 `SHARED` 就行了？**
    
    - _深度提醒：不完全是，Windows 还需要处理 `__declspec(dllexport)`，这是 CMake 最头疼的跨平台细节之一。_
        

**你想针对 Windows DLL 的导出（Export）深挖一下，还是直接开启“第二阶段：逻辑控制（If/Else 和 Option 开关）”？**