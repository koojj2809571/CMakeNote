CMake 中的变量操作是构建脚本的基础。在 CMake 中，变量主要分为**普通变量 (Normal Variables)**、**缓存变量 (Cache Variables)** 和 **环境变量 (Environment Variables)**。

以下是关于 **普通变量** 相关操作的详细详解：

---

## 1. 变量的定义与赋值

在 CMake 中，使用 `set()` 命令来定义或修改变量。变量名通常是大写的（虽然不强制），且区分大小写。

### 基本语法

CMake

```
set(VAR_NAME "value")
```

- **字符串赋值**：`set(MY_STR "Hello World")`
    
- **列表赋值**：CMake 的列表本质上是以分号 `;` 分隔的字符串。
    
    - 方式一：`set(MY_LIST a b c)` # 结果为 "a;b;c"
        
    - 方式二：`set(MY_LIST "a;b;c")`
        
- **空值/删除**：`set(MY_VAR)` 或 `set(MY_VAR "")` 会将变量设为空。
    

---

## 2. 变量的引用

要获取变量的值，使用 `${}` 语法。

CMake

```
set(PROJECT_NAME "MyApp")
message(STATUS "Project name is: ${PROJECT_NAME}")
```

> **注意**：如果你引用一个未定义的变量，CMake 不会报错，而是返回一个空字符串。

---

## 3. 变量的范围 (Scope)

理解作用域是掌握 CMake 变量的关键。普通变量的作用域具有**继承性**和**局限性**。

- **父子目录作用域**：当你在主 `CMakeLists.txt` 中 `add_subdirectory(child)` 时，子目录会**拷贝**一份父目录当前的变量副本。
    
    - 子目录修改变量，**不会**影响父目录。
        
    - 子目录定义的变量，在父目录中**不可见**。
        
- **函数作用域**：在 `function()` 内部定义的变量是局部的，外部不可见。
    
- **宏 (Macro)**：`macro()` 不产生新的作用域，内部的操作等同于直接替换代码，会影响调用者的变量。
    

### 强制向上传递：`PARENT_SCOPE`

如果你希望在子目录或函数中修改父作用域的变量，需要使用 `PARENT_SCOPE` 关键字：

CMake

```
set(MY_VAR "new_value" PARENT_SCOPE)
```

---

## 4. 变量的追加与拼接

除了重新 `set`，CMake 提供了专门操作列表变量的命令。

### 使用 `list` 命令

CMake

```
set(MY_LIST "a" "b")

# 追加元素
list(APPEND MY_LIST "c" "d") # MY_LIST 现在是 "a;b;c;d"

# 获取长度
list(LENGTH MY_LIST MY_SIZE)

# 移除特定元素
list(REMOVE_ITEM MY_LIST "b")
```

### 字符串拼接

可以直接在 `set` 中引用旧值：

CMake

```
set(MY_STR "Hello")
set(MY_STR "${MY_STR} World") # 结果为 "Hello World"
```

---

## 5. 变量的检查与解引用

### 检查变量是否定义

CMake

```
if(DEFINED MY_VAR)
    message("Variable is defined.")
endif()
```

### 嵌套引用 (嵌套解引用)

CMake 支持从右向左解析嵌套的 `${}`。

CMake

```
set(VAR_NAME "REAL_VALUE")
set(REAL_VALUE "Success")

message(STATUS "Result: ${${VAR_NAME}}") # 输出 "Result: Success"
```

---

## 6. 常见内置普通变量

CMake 预定义了许多有用的普通变量：

|**变量名**|**含义**|
|---|---|
|`CMAKE_SOURCE_DIR`|工程根目录（最顶层 CMakeLists 所在位置）|
|`CMAKE_CURRENT_SOURCE_DIR`|当前处理的 CMakeLists 所在目录|
|`CMAKE_BINARY_DIR`|构建目录（Build 目录）的根路径|
|`PROJECT_NAME`|最近一次 `project()` 命令定义的项目名|

---

### 总结建议

- **优先使用普通变量**来处理逻辑，仅在需要跨多次配置持久化（如编译器路径、开关选项）时使用**缓存变量 (CACHE)**。
    
- 调试变量时，使用 `message(STATUS "VAR_NAME = ${VAR_NAME}")` 是最简单的手段。
    

您是正在编写大型项目的模块化构建脚本，还是在处理特定库的链接问题？我可以为您演示如何跨目录管理这些变量。